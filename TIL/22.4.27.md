# Done



# TIL





**메모리 관리 목표 **

- 여러 프로세스가 동시에 실행될 수 있도록 메모리 공간을 제공
- 시스템 사용자들을 위해 만족할 만한 수준의 성능을 제공
- 각 프로그램의 리소스를 보호
- 프로세스 사이에 있는 메모리 공간 공유
- 프로그래머를 위해 되도록 메모리 공간의 주소를 투명하게 유지
- 각각의 프로세스는 독립된 메모리 공간을 갖고, 운영체제 혹을 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있음
- 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않기 때문에 운영체제에서 메모리를 관리
- 멀티프로그래밍 환경으로 변화하면서 한정된 메모리를 효율적으로 사용하기위함

**Swift는 어떤 식으로 메모리를 관리하나? **

- ARC(Automatic Reference Count)를 사용
- 클래스의 새로운 인스턴스에 대한 정보를 저장하기 위해 메모리 chunk 할당
  - 인스턴스의 저장 프로퍼티와 연관된 값과 함께 인스턴스의 타입에 관한 정보 유지
- 클래스 인스턴스에 할당된 메모리들을 인스턴스들이 필요하지 않을 때 자동적으로 메모리를 비워줌
- 인스턴스의 프로퍼티 접근이나 인스턴스 메소드의 더 이상 호출할 수 없음 ( 접근시 crash )



| -                  | strong                             | weak                               | unowned                                         |
| ------------------ | ---------------------------------- | ---------------------------------- | ----------------------------------------------- |
| Reference Counting | O                                  | X                                  | X                                               |
| var                | O                                  | O                                  | O                                               |
| let                | O                                  | X                                  | O                                               |
| optional           | O                                  | O                                  | X                                               |
| non-optional       | O                                  | X                                  | O                                               |
| memory release     | 명시적으로 nil 할당                | auto deinit nil 할당               | auto deinit 메모리 주소를 계속 갖고 있음        |
| expected problem   | Strong Reference Cycle Memory Leak | 인스턴스 해제 후 접근하면 nil 반환 | 인스턴스 해제 후 접근하면 오류 Dangling Pointer |



**순환 참조가 일어날 수 있는 상황은 무엇인가? **

- 서로 다른 인스턴스가 서로를 강하게 참조하고 있는경우 참조 카운트를 0으로 만들지못해 메모리에서 해제 되지 않음 (강한 순환참조)

**Weak 참조와 Unowned 참조의 차이는?**

- weak 와 unowned 의 경우 참조 카운트를 증가시키지 않음
- unowned 참조는 weak와 다르게 인스턴스를 참조하는 도중에 해당 인스턴스가 메모리에서 사라질 일이 없다고 가정하기 때문에 weak와 달리 암묵적으로 옵셔널을 해제(!)하여 선언
- unowned 참조는 참조하고 있던 인스턴스가 먼저 메모리에서 해제될 때 nil을 할당할 수 없어 오류를 발생시키므로 위험한 방법

**Xcode에서 메모리 누수를 직접 일으킨 다음, 어떤 현상이 발생하는지, 어떻게 탐지할 수 있는지 스크린샷을 캡처하시오**



```swift
class 강한참조1 {
    var 참조2: 강한참조2?

    init() {
        print("강한참조1 init") }
    deinit {
        print("강한참조1 deinit") }
}

class 강한참조2 {
    var 참조1: 강한참조1?
    
    init() {
        print("강한참조2 init") }
    deinit {
        print("강한참조2 deinit") }
}

var 강한참조인스턴스1: 강한참조1? = 강한참조1()
var 강한참조인스턴스2: 강한참조2? = 강한참조2()

강한참조인스턴스1?.참조2 = 강한참조인스턴스2
강한참조인스턴스2?.참조1 = 강한참조인스턴스1
강한참조인스턴스1 = nil
강한참조인스턴스2 = nil
print(강한참조인스턴스1)
print(강한참조인스턴스2)
```



<img width="705" src="https://user-images.githubusercontent.com/78553659/165540894-83ca9544-ebd0-45f7-8d82-0be8952b30e8.png">

```swift
class 강한참조 {
    var 참조: 약한참조?

    init() {
        print("강한참조 init") }
    deinit {
        print("강한참조 deinit") }
}

class 약한참조 {
    weak var 참조: 강한참조?
    
    init() {
        print("약한참조 init") }
    deinit {
        print("약한참조 deinit") }
}

var 강한참조인스턴스: 강한참조? = 강한참조()
var 약한참조인스턴스: 약한참조? = 약한참조()

강한참조인스턴스?.참조 = 약한참조인스턴스
약한참조인스턴스?.참조 = 강한참조인스턴스
강한참조인스턴스 = nil
약한참조인스턴스 = nil
print(강한참조인스턴스)
print(약한참조인스턴스)
```

<img width="710" src="https://user-images.githubusercontent.com/78553659/165540881-7544b9cd-3fcc-4de5-b245-732a0d04314b.png">

